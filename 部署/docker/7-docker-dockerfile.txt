1.使用dockerfile定制镜像
创建Dockerfile文件
FROM nginx
RUN echo 'this is local nginx' > /usr/share/nginx/html/index.html

FROM ：定制的镜像都是基于FROM的镜像。
RUN ： 用于执行后面跟着的命令，有两种格式
--shell格式：
RUN 命令行，等同于在终端操作的shell命令
--exec格式：
RUN ["可执行文件","参数1","参数2"]

每执行一次RUN都会创建一层镜像，所以尽量把命令写在一行。
FROM centos
RUN yum install wget
RUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"
RUN tar -xvf redis.tar.gz
以上命令会创建3层镜像可以简化为下面的命令
FROM centos
RUN yum install wget \
    && wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \
    && tar -xvf redis.tar.gz
用&&符号连接可以视为一条命令

2.开始构建镜像
在存放Dockerfile文件的文件夹下构建
docker build -t nginx:test .
上下文路径：是指docker在构建镜像，有时候要使用到本机的文件，docker build这个命令得知这个路径后，会将路径下的所有内容打包。
由于docker的运行模式是C/S，本机是C，docker引擎是S。实际的构建过程是在docker引擎下完成的，所以这个时候无法用到我们本机的文件。
这就需要把我们本机指定目录下的文件一起打包提供给docker引擎使用。
如果没有说明最后一个参数，那么默认上下文路径就是Dockerfile所在的位置，上下文路径不应该放无用的文件，因为会一起打包给dcoker引擎，
文件过多会造成过程缓慢。

3.指令详解
--COPY ：复制，从上下文目录中复制文件到容器里的指定路径 
COPY [--chown=<user>:<group>] <源路径1>...  <目标路径>
COPY [--chown=<user>:<group>] ["<源路径1>",...  "<目标路径>"]
[--chown=<user>:<group>] 为可选项，用户可以通过该选项改变复制到容器内的文件的拥有者和属组
COPY hom* /mydir/
COPY hom?.txt /mydir/
目标路径不存在会自动创建

--ADD：与copy功能类似，格式一致
不同之处在于：
ADD优点是在执行<源文件>为tar压缩文件的话，压缩格式为gzip，bzip2以及xz的情况下，会自动复制并解压到<目标路径>
ADD缺点是再不解压的前提下，无法复制tar压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用可以根据是否需要自动解压来决定。

--CMD：类似于RUN，用于运行程序，但是二者运行时间不同
CMD在docker run时运行
RUN是在docker build时运行
cmd指定的程序可以被docker run 命令行参数中指定要运行的程序所覆盖
如果dockerfile中有多个cmd，只有最后一个生效
CMD <shell 命令> 
CMD ["<可执行文件或命令>","<param1>","<param2>",...] 
CMD ["<param1>","<param2>",...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数
推荐使用第二种，第一种在实际运行时也会转换成第二种，并且默认可执行文件是sh

--ENTRYPOINT：类似于CMD,但不会被docker run 的命令行参数覆盖，而且这些命令行参数会被当做参数送给ENTRYPOINT指令指定的程序
但如果运行docker run时使用了--entrypoint选项，此选项的参数可当作要运行的程序覆盖ENTRYPOINT指定指定的程序。
如果有多个ENTRYPOINT，只有最后一个生效
ENTRYPOINT ["<executeable>","<param1>","<param2>",...]
可以和CMD搭配使用，一般是变参才会使用CMD，这里的CMD等于给ENTRYPOINT传参。
假设已经通过dockerfile构建了nginx：test镜像
FROM nginx

ENTRYPOINT ["nginx", "-c"] # 定参
CMD ["/etc/nginx/nginx.conf"] # 变参 
--1.不传参运行
docker run nginx:test
容器内会默认运行： nginx -c /etc/nginx/nginx.conf
--2.传参运行
docker run nginx:test -c /etc/nginx/new.conf
容器内会默认运行：nginx -c /etc/nginx/new.conf

--ENV：设置环境变量，设置后在后续的指令中就可以使用这个环境变量
ENV <key> <value>
ENV <key1>=<value1> <key2>=<value2>...
ENV NODE_VERSION 7.2.0
RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz" \
  && curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc"

--ARG：构建参数，与ENV作用一致，不过作用域不一样。
ARG设置的环境变量仅对Dockerfile内有效，也就是说只有docker build 的过程中有效，构建好的镜像内不存在此环境变量。
可以被docker build --build-arg <参数名>=<值> 来覆盖
ARG <参数名>[=<默认值>]

--VOLUME：定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷
作用是避免重要数据因容器重启而丢失，和避免容器不断变大。
VOLUME ["<路径1>", "<路径2>"...]
VOLUME <路径>
在docker run 的时候可以通过-v修改挂载点

--EXPOSE：仅仅只是声明端口
可以帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。
在运行时使用自动映射，也就是docker run -P时，会自动映射EXPOSE
EXPOSE <端口1> [<端口2>...]

--WORKDIR：指定工作目录
用WORKDIR指定的工作目录，会在构建镜像的每一层中存在。该目录必须提前创建好。
docker build 构建镜像过程中，每一个run都是新建的一层。只有通过WORKDIR创建的目录才会一直存在。
WORKDIR <工作目录路径>

--USER：用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前存在）
USER <用户名>[:<用户组>]

--HEALTHCHECK：用于指定某个程序或者指令来监控docker容器服务的运行状态
HEALTHCHECK [选项] CMD <命令>：设置检查容器健康状况的命令
HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令
HEALTHCHECK [选项] CMD <命令> : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。

--ONBUILD：用于延迟构建命令的执行。
当dockerfile里用onbuild指定的命令，在本次构建镜像的过程中不会执行。
当有新的dockerfile使用了之前构建的镜像FROM test-build,这是执行新镜像的dockerfile构建时候，会执行test-build的onbuild指定的命令
ONBUILD <其它指令>



